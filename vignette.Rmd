---
title: "RNA sequencing analyses in families with multiple affected of bipolar disorder"
author: "Inés García-Ortiz"
date: "2022-11-29"
output: word_document
bibliography: references.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

The purpose of this vignette is to complement, describe and explain the scripts created for my master thesis project, in which RNAseq data from 31 different individuals undergoes different analyses.

# How does the data look?

We have RNAseq data from 31 different individuals of 8 different families with high number of Bipolar Disorder affected relatives. They have two different IDs: the individual ID present in the databank of the group and the sample ID used for the RNAseq itself.

| Databank ID | RNAseq ID | Condition  | Gender | Age   | Family |
|-------------|-----------|------------|--------|-------|--------|
| 21873       | BWH011    | Affected   | Male   | adult | 210    |
| 12005       | BWH002    | Unaffected | Male   | elder | 120    |
| 12001       | BWH003    | Unaffected | Male   | adult | 120    |
| 12002       | BWH004    | Unaffected | Male   | adult | 120    |
| 12003       | BWH005    | Affected   | Female | adult | 120    |
| 12004       | BWH006    | Affected   | Female | adult | 120    |
| 21769       | BWH007    | Affected   | Male   | adult | 172    |
| 21768       | BWH008    | Unaffected | Female | adult | 172    |
| 21770       | BWH009    | Affected   | Female | young | 172    |
| 21771       | BWH010    | Affected   | Female | young | 172    |
| 12504       | BWH012    | Unaffected | Male   | elder | 125    |
| 12500       | BWH013    | Unaffected | Female | elder | 125    |
| 12506       | BWH014    | Affected   | Male   | adult | 125    |
| 2701        | BWH015    | Unaffected | Male   | elder | 27     |
| 2700        | BWH016    | Affected   | Female | elder | 27     |
| 2705        | BWH017    | Affected   | Female | young | 27     |
| 2706        | BWH018    | Affected   | Male   | adult | 27     |
| 2707        | BWH019    | Unaffected | Female | adult | 27     |
| 7203        | BWH000    | Affected   | Male   | young | 72     |
| 7204        | BWH001    | Affected   | Male   | young | 72     |
| 7201        | BWH020    | Unaffected | Male   | elder | 72     |
| 7200        | BWH021    | Unaffected | Female | elder | 72     |
| 7202        | BWH022    | Affected   | Male   | young | 72     |
| 12709       | BWH023    | Unaffected | Male   | elder | 127    |
| 12700       | BWH024    | Unaffected | Female | elder | 127    |
| 12708       | BWH025    | Affected   | Male   | young | 127    |
| 6504        | BWH026    | Affected   | Male   | elder | 65     |
| 6506        | BWH027    | Unaffected | Female | elder | 65     |
| 6502        | BWH028    | Unaffected | Male   | adult | 65     |
| 6503        | BWH029    | Unaffected | Female | adult | 65     |
| 6500        | BWH030    | Affected   | Male   | adult | 65     |

The pedigree family structures is the following:

(insertar imagen pedigris)

# Data processing in bash

## Preprocessing of reads

The original fastq files come in three files for running files, that had to be concatenated.

```{bash eval = FALSE}
#!/bin/bash
cd /home/proyectos/genpsych/RNAseq/RNAseq_FastaQ/
for d in BWH--[0-9][0-9][0-9]
do
	cd $d
	#Uncompress
	gunzip -c *R1.fastq.gz > $d_R1.fastq
	gunzip -c *R2.fastq.gz > $d_R2.fastq
	#Move to my folder
	mv *fastq ../fastqInes	
	cd ..
	echo continuing
done

```

A first fastQC assay was done, using the program with the same name[@andrews2010]:

```{bash eval = FALSE}
#!/bin/bash
module load fastqc/0.11.9
fastqc *fastq -t 20 -o FASTQC
```

Though the overall quality of the reads was very good, I decided to trim a little bit the ends using Trimmomatic[@bolger2014]. To generate the commands for each sample the script used was:

```{bash eval = FALSE}
#!/bin/bash
for i in `ls -1 *R1.fastq | sed 's/\_R1.fastq//'`; 
do 
echo java -jar /usr/local/trimmomatic/0.39/trimmomatic-0.39.jar PE -threads 20 
-phred33 $i\_R1.fastq $i\_R2.fastq $i\_R1_paired.fq.gz $i\_R1_unpaired.fq.gz $i\_R2_paired.fq.gz $i\_R2_unpaired.fq.gz 
SLIDINGWINDOW:4:20 MINLEN:50 >> trim_cmd; 
done
```

The command first has to call to java and declare that it is a paired end (*PE*) experiment. The sliding window (*SLIDINGWINDOW:4:20*) in trimmomatic means that it will scan the read from the 5' end in groups of **4** and when the average quality drops from **20** it will clip it. We will only accept reads with a minimum length (*MINLEN:50*) of 50 basepairs.

Giving the following whole script:

```{bash eval = FALSE}
#!/bin/bash
module load trimmomatic/0.39
java -jar /usr/local/trimmomatic/0.39/trimmomatic-0.39.jar PE -threads 20 -phred33 BWH--000_R1.fastq BWH--000_R2.fastq BWH--000_R1_paired.fq.gz BWH--000_R1_unpaired.fq.gz BWH--000_R2_paired.fq.gz BWH--000_R2_unpaired.fq.gz SLIDINGWINDOW:4:20 MINLEN:50
java -jar /usr/local/trimmomatic/0.39/trimmomatic-0.39.jar PE -threads 20 -phred33 BWH--001_R1.fastq BWH--001_R2.fastq BWH--001_R1_paired.fq.gz BWH--001_R1_unpaired.fq.gz BWH--001_R2_paired.fq.gz BWH--001_R2_unpaired.fq.gz SLIDINGWINDOW:4:20 MINLEN:50
java -jar /usr/local/trimmomatic/0.39/trimmomatic-0.39.jar PE -threads 20 -phred33 BWH--002_R1.fastq BWH--002_R2.fastq BWH--002_R1_paired.fq.gz BWH--002_R1_unpaired.fq.gz BWH--002_R2_paired.fq.gz BWH--002_R2_unpaired.fq.gz SLIDINGWINDOW:4:20 MINLEN:50
java -jar /usr/local/trimmomatic/0.39/trimmomatic-0.39.jar PE -threads 20 -phred33 BWH--003_R1.fastq BWH--003_R2.fastq BWH--003_R1_paired.fq.gz BWH--003_R1_unpaired.fq.gz BWH--003_R2_paired.fq.gz BWH--003_R2_unpaired.fq.gz SLIDINGWINDOW:4:20 MINLEN:50
java -jar /usr/local/trimmomatic/0.39/trimmomatic-0.39.jar PE -threads 20 -phred33 BWH--004_R1.fastq BWH--004_R2.fastq BWH--004_R1_paired.fq.gz BWH--004_R1_unpaired.fq.gz BWH--004_R2_paired.fq.gz BWH--004_R2_unpaired.fq.gz SLIDINGWINDOW:4:20 MINLEN:50
java -jar /usr/local/trimmomatic/0.39/trimmomatic-0.39.jar PE -threads 20 -phred33 BWH--005_R1.fastq BWH--005_R2.fastq BWH--005_R1_paired.fq.gz BWH--005_R1_unpaired.fq.gz BWH--005_R2_paired.fq.gz BWH--005_R2_unpaired.fq.gz SLIDINGWINDOW:4:20 MINLEN:50
java -jar /usr/local/trimmomatic/0.39/trimmomatic-0.39.jar PE -threads 20 -phred33 BWH--006_R1.fastq BWH--006_R2.fastq BWH--006_R1_paired.fq.gz BWH--006_R1_unpaired.fq.gz BWH--006_R2_paired.fq.gz BWH--006_R2_unpaired.fq.gz SLIDINGWINDOW:4:20 MINLEN:50
java -jar /usr/local/trimmomatic/0.39/trimmomatic-0.39.jar PE -threads 20 -phred33 BWH--007_R1.fastq BWH--007_R2.fastq BWH--007_R1_paired.fq.gz BWH--007_R1_unpaired.fq.gz BWH--007_R2_paired.fq.gz BWH--007_R2_unpaired.fq.gz SLIDINGWINDOW:4:20 MINLEN:50
java -jar /usr/local/trimmomatic/0.39/trimmomatic-0.39.jar PE -threads 20 -phred33 BWH--008_R1.fastq BWH--008_R2.fastq BWH--008_R1_paired.fq.gz BWH--008_R1_unpaired.fq.gz BWH--008_R2_paired.fq.gz BWH--008_R2_unpaired.fq.gz SLIDINGWINDOW:4:20 MINLEN:50
java -jar /usr/local/trimmomatic/0.39/trimmomatic-0.39.jar PE -threads 20 -phred33 BWH--009_R1.fastq BWH--009_R2.fastq BWH--009_R1_paired.fq.gz BWH--009_R1_unpaired.fq.gz BWH--009_R2_paired.fq.gz BWH--009_R2_unpaired.fq.gz SLIDINGWINDOW:4:20 MINLEN:50
java -jar /usr/local/trimmomatic/0.39/trimmomatic-0.39.jar PE -threads 20 -phred33 BWH--010_R1.fastq BWH--010_R2.fastq BWH--010_R1_paired.fq.gz BWH--010_R1_unpaired.fq.gz BWH--010_R2_paired.fq.gz BWH--010_R2_unpaired.fq.gz SLIDINGWINDOW:4:20 MINLEN:50
java -jar /usr/local/trimmomatic/0.39/trimmomatic-0.39.jar PE -threads 20 -phred33 BWH--011_R1.fastq BWH--011_R2.fastq BWH--011_R1_paired.fq.gz BWH--011_R1_unpaired.fq.gz BWH--011_R2_paired.fq.gz BWH--011_R2_unpaired.fq.gz SLIDINGWINDOW:4:20 MINLEN:50
java -jar /usr/local/trimmomatic/0.39/trimmomatic-0.39.jar PE -threads 20 -phred33 BWH--012_R1.fastq BWH--012_R2.fastq BWH--012_R1_paired.fq.gz BWH--012_R1_unpaired.fq.gz BWH--012_R2_paired.fq.gz BWH--012_R2_unpaired.fq.gz SLIDINGWINDOW:4:20 MINLEN:50
java -jar /usr/local/trimmomatic/0.39/trimmomatic-0.39.jar PE -threads 20 -phred33 BWH--013_R1.fastq BWH--013_R2.fastq BWH--013_R1_paired.fq.gz BWH--013_R1_unpaired.fq.gz BWH--013_R2_paired.fq.gz BWH--013_R2_unpaired.fq.gz SLIDINGWINDOW:4:20 MINLEN:50
java -jar /usr/local/trimmomatic/0.39/trimmomatic-0.39.jar PE -threads 20 -phred33 BWH--014_R1.fastq BWH--014_R2.fastq BWH--014_R1_paired.fq.gz BWH--014_R1_unpaired.fq.gz BWH--014_R2_paired.fq.gz BWH--014_R2_unpaired.fq.gz SLIDINGWINDOW:4:20 MINLEN:50
java -jar /usr/local/trimmomatic/0.39/trimmomatic-0.39.jar PE -threads 20 -phred33 BWH--015_R1.fastq BWH--015_R2.fastq BWH--015_R1_paired.fq.gz BWH--015_R1_unpaired.fq.gz BWH--015_R2_paired.fq.gz BWH--015_R2_unpaired.fq.gz SLIDINGWINDOW:4:20 MINLEN:50
java -jar /usr/local/trimmomatic/0.39/trimmomatic-0.39.jar PE -threads 20 -phred33 BWH--016_R1.fastq BWH--016_R2.fastq BWH--016_R1_paired.fq.gz BWH--016_R1_unpaired.fq.gz BWH--016_R2_paired.fq.gz BWH--016_R2_unpaired.fq.gz SLIDINGWINDOW:4:20 MINLEN:50
java -jar /usr/local/trimmomatic/0.39/trimmomatic-0.39.jar PE -threads 20 -phred33 BWH--017_R1.fastq BWH--017_R2.fastq BWH--017_R1_paired.fq.gz BWH--017_R1_unpaired.fq.gz BWH--017_R2_paired.fq.gz BWH--017_R2_unpaired.fq.gz SLIDINGWINDOW:4:20 MINLEN:50
java -jar /usr/local/trimmomatic/0.39/trimmomatic-0.39.jar PE -threads 20 -phred33 BWH--018_R1.fastq BWH--018_R2.fastq BWH--018_R1_paired.fq.gz BWH--018_R1_unpaired.fq.gz BWH--018_R2_paired.fq.gz BWH--018_R2_unpaired.fq.gz SLIDINGWINDOW:4:20 MINLEN:50
java -jar /usr/local/trimmomatic/0.39/trimmomatic-0.39.jar PE -threads 20 -phred33 BWH--019_R1.fastq BWH--019_R2.fastq BWH--019_R1_paired.fq.gz BWH--019_R1_unpaired.fq.gz BWH--019_R2_paired.fq.gz BWH--019_R2_unpaired.fq.gz SLIDINGWINDOW:4:20 MINLEN:50
java -jar /usr/local/trimmomatic/0.39/trimmomatic-0.39.jar PE -threads 20 -phred33 BWH--020_R1.fastq BWH--020_R2.fastq BWH--020_R1_paired.fq.gz BWH--020_R1_unpaired.fq.gz BWH--020_R2_paired.fq.gz BWH--020_R2_unpaired.fq.gz SLIDINGWINDOW:4:20 MINLEN:50
java -jar /usr/local/trimmomatic/0.39/trimmomatic-0.39.jar PE -threads 20 -phred33 BWH--021_R1.fastq BWH--021_R2.fastq BWH--021_R1_paired.fq.gz BWH--021_R1_unpaired.fq.gz BWH--021_R2_paired.fq.gz BWH--021_R2_unpaired.fq.gz SLIDINGWINDOW:4:20 MINLEN:50
java -jar /usr/local/trimmomatic/0.39/trimmomatic-0.39.jar PE -threads 20 -phred33 BWH--022_R1.fastq BWH--022_R2.fastq BWH--022_R1_paired.fq.gz BWH--022_R1_unpaired.fq.gz BWH--022_R2_paired.fq.gz BWH--022_R2_unpaired.fq.gz SLIDINGWINDOW:4:20 MINLEN:50
java -jar /usr/local/trimmomatic/0.39/trimmomatic-0.39.jar PE -threads 20 -phred33 BWH--023_R1.fastq BWH--023_R2.fastq BWH--023_R1_paired.fq.gz BWH--023_R1_unpaired.fq.gz BWH--023_R2_paired.fq.gz BWH--023_R2_unpaired.fq.gz SLIDINGWINDOW:4:20 MINLEN:50
java -jar /usr/local/trimmomatic/0.39/trimmomatic-0.39.jar PE -threads 20 -phred33 BWH--024_R1.fastq BWH--024_R2.fastq BWH--024_R1_paired.fq.gz BWH--024_R1_unpaired.fq.gz BWH--024_R2_paired.fq.gz BWH--024_R2_unpaired.fq.gz SLIDINGWINDOW:4:20 MINLEN:50
java -jar /usr/local/trimmomatic/0.39/trimmomatic-0.39.jar PE -threads 20 -phred33 BWH--025_R1.fastq BWH--025_R2.fastq BWH--025_R1_paired.fq.gz BWH--025_R1_unpaired.fq.gz BWH--025_R2_paired.fq.gz BWH--025_R2_unpaired.fq.gz SLIDINGWINDOW:4:20 MINLEN:50
java -jar /usr/local/trimmomatic/0.39/trimmomatic-0.39.jar PE -threads 20 -phred33 BWH--026_R1.fastq BWH--026_R2.fastq BWH--026_R1_paired.fq.gz BWH--026_R1_unpaired.fq.gz BWH--026_R2_paired.fq.gz BWH--026_R2_unpaired.fq.gz SLIDINGWINDOW:4:20 MINLEN:50
java -jar /usr/local/trimmomatic/0.39/trimmomatic-0.39.jar PE -threads 20 -phred33 BWH--027_R1.fastq BWH--027_R2.fastq BWH--027_R1_paired.fq.gz BWH--027_R1_unpaired.fq.gz BWH--027_R2_paired.fq.gz BWH--027_R2_unpaired.fq.gz SLIDINGWINDOW:4:20 MINLEN:50
java -jar /usr/local/trimmomatic/0.39/trimmomatic-0.39.jar PE -threads 20 -phred33 BWH--028_R1.fastq BWH--028_R2.fastq BWH--028_R1_paired.fq.gz BWH--028_R1_unpaired.fq.gz BWH--028_R2_paired.fq.gz BWH--028_R2_unpaired.fq.gz SLIDINGWINDOW:4:20 MINLEN:50
java -jar /usr/local/trimmomatic/0.39/trimmomatic-0.39.jar PE -threads 20 -phred33 BWH--029_R1.fastq BWH--029_R2.fastq BWH--029_R1_paired.fq.gz BWH--029_R1_unpaired.fq.gz BWH--029_R2_paired.fq.gz BWH--029_R2_unpaired.fq.gz SLIDINGWINDOW:4:20 MINLEN:50
java -jar /usr/local/trimmomatic/0.39/trimmomatic-0.39.jar PE -threads 20 -phred33 BWH--030_R1.fastq BWH--030_R2.fastq BWH--030_R1_paired.fq.gz BWH--030_R1_unpaired.fq.gz BWH--030_R2_paired.fq.gz BWH--030_R2_unpaired.fq.gz SLIDINGWINDOW:4:20 MINLEN:50

```

The next fastQC shows that the ends of the reads now present a much better quality:

```{bash eval = FALSE}
#!/bin/bash
module load fastqc/0.11.9
fastqc *paired.fq.gz -t 20 -o FASTQC_afterTrim
```

## Genome download

I will use the reference genome GRCh38 from Ensembl as one of my future plans is to make a new transcript analysis and an alternative splicing analysis, though this is beyond the scope of this master thesis project. First the fasta file has to be downloaded chromosome by chromosome and store in a single file:

```{bash eval = FALSE}
#!/bin/bash
for chr in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 MT X Y

do
echo Starting with chromosome ${chr}

wget http://ftp.ensembl.org/pub/current_fasta/homo_sapiens/dna/Homo_sapiens.GRCh38.dna.chromosome.${chr}.fa.gz
cat Homo_sapiens.GRCh38.dna.chromosome.${chr}.fa.gz >> Homo_sapiens.GRCh38.dna.chromosome.all.fa.gz
#Have a marker to check the process:
echo Added the following bytes to general fasta:
stat -c %s Homo_sapiens.GRCh38.dna.chromosome.all.fa.gz

rm Homo_sapiens.GRCh38.dna.chromosome.${chr}*
echo Finishing with chromosome ${chr}
done

```

Then the annotation file is downloaded:

```{bash eval = FALSE}
#!/bin/bash
wget http://ftp.ensembl.org/pub/release-107/gtf/homo_sapiens/Homo_sapiens.GRCh38.107.chr.gtf.gz
gunzip Homo_sapiens.GRCh38.107.chr.gtf.gz
```

## Read alignment

The next step is to align the reads to the reference genome:

```{bash eval = FALSE}
#!/bin/bash
module load hisat2/2.1.0
module load samtools/1.9

#Build index
hisat2-build Homo_sapiens.GRCh38.dna.chromosome.all.fa hg38

#Align each sample
for index in 00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30

do
        echo Starting with sample ${index}
        hisat2 -q --rna-strandness RF -k 1 -p 4 -x hg38 -1 trimmed_paired_fastq/BWH0${index}_R1_paired.fq -2 trimmed_paired_fastq/BWH0${index}_R2_paired.fq -S BWH0${index}.sam 2>> summary_alignment.txt

        echo Getting into samtools, sample ${index}
        samtools view -@ 4 -bo BWH0${index}.sam BWH0${index}.bam
        samtools sort -@ 4 -o BWH0${index}_sorted.bam BWH0${index}.bam
        samtools index BWH0${index}_sorted.bam
        echo Finishing with sample ${index}
done
```

In the first paragraph of the loop the alignment as it is is performed, using hisat2[@kim2019]. The second part of the loop uses samtools[@li2009] to transform the sam files into bam files (much smaller in size) and sorting and indexing of the reads by their coordinates.

The results of this process is very satisfactory:

```{bash eval = FALSE}
grep overall summary_alignment.txt
98.14% overall alignment rate
98.26% overall alignment rate
98.29% overall alignment rate
98.30% overall alignment rate
97.86% overall alignment rate
97.64% overall alignment rate
97.67% overall alignment rate
97.59% overall alignment rate
96.79% overall alignment rate
97.87% overall alignment rate
97.81% overall alignment rate
98.03% overall alignment rate
98.17% overall alignment rate
97.68% overall alignment rate
97.39% overall alignment rate
97.18% overall alignment rate
96.08% overall alignment rate
97.01% overall alignment rate
96.83% overall alignment rate
97.40% overall alignment rate
97.50% overall alignment rate
97.70% overall alignment rate
96.89% overall alignment rate
97.34% overall alignment rate
97.73% overall alignment rate
97.34% overall alignment rate
96.92% overall alignment rate
97.40% overall alignment rate
97.42% overall alignment rate
97.49% overall alignment rate
97.33% overall alignment rate

grep overall summary_alignment.txt | wc -l
31
```

## Gene quantification

The gene quantification was done using htseq-count[@anders2014], a Python package.

```{bash eval = FALSE}
#!/bin/bash
module load miniconda/3.7
ls -l *sorted.bam | sed 's/_sorted.bam//g' > lista.txt

cat lista.txt | while read index
do
        echo Starting with ${index}
        htseq-count -f bam -r pos -m intersection-strict --stranded reverse 
        --minaqual 1 -t gene --idattr gene_id ${index}_sorted.bam 
        Homo_sapiens.GRCh38.107.chr.gtf > ${index}.tsv

        echo Finishing with ${index}
done

```

Out of the arguments of this command arguably the most interesting is *-m intersection-strict*, which specifies the way the overlaps are managed. If the read is in the range of a coding exon but it is present outside its boundaries, it is interpreted as if this read has no gene match.

# Differential Gene Expression analysis

The DGE analysis aims to detect if there are any differentially expressed genes between the affected and unaffected individuals. To proceed first step is to load the libraries[@rstudioapi; @gplots; @ggplot2; @pheatmap; @DESeq2; @org.Hs.eg.db; @EnhancedVolcano; @ggrepel]. This script is based on the one used in the Genomics assistance unit of the CBMSO, done by Ramón Peiró-Pastor, Eva Castillo Rosa, Eva Sacristán and Sandra González, inspired on the draft of Alberto Rastrojo, as well as from the DESeq2 vignette [@love2014].

```{r eval = FALSE}
suppressPackageStartupMessages({
  library(rstudioapi)
  library(gplots, quietly = T)
  library(ggplot2, quietly = TRUE)
  library(pheatmap, quietly = TRUE)
  library(DESeq2, quietly = TRUE)
  library('org.Hs.eg.db', quietly = TRUE, character.only = TRUE)
  library(EnhancedVolcano, quietly = TRUE)
})
require("ggrepel", quietly = TRUE)
```

With the next chunk I specify the paths for the input and output file: it is easier to change the names and directories here rather than look for them in the script. I also specify the working directory, for which I use rstudioapi to detect the source file location.

```{r eval = FALSE}
#Paths
workingD <- rstudioapi::getActiveDocumentContext()$path
setwd(dirname(workingD))
#Input
configFile <- 'configfile.txt'
#Outputs
resD <- 'results_DGE/'
rawCountsF <- paste0(resD,"counts_raw.tsv")
normCountsF <- paste0(resD,"counts_normalized.tsv")
PCAF <- paste0(resD,"PCA.tiff")
distancesF <- paste0(resD,"distances.tiff")
dispersionF <- paste0(resD,"dispersion.tiff")
MAplotF <- paste0(resD,"maplot.tiff")
genesTSV <- paste0(resD,"all_genes.tsv")
sigTSV <- paste0(resD,"sig_pval.tsv")
sigPCAF <- paste0(resD,"PCA_sig.tiff")
alphasigTSV <- paste0(resD,"0.05_sig_padj.tsv")
volcanoF <- paste0(resD,"volcanoPlot.jpeg")
heatmapF <- paste0(resD,"heatmap.jpeg")
```

Then I set the parameters that will be later used. Again, it is easier to specify them at the start of the script for making multiple trials rather than look for them in the script:

```{r eval = FALSE}
cutoff <- 0.05 #significancy p value adjusted
FCthres <- 4 #fold change threshold to consider in graphs
covs <- T
```

I also made a function to make the names in the axis of some charts in italics:

```{r eval = FALSE}
make_italics <- function(x){
  as.expression(lapply(x, function(y) bquote(italic(.(y)))))
}
```

Now that it's everything settled, it is the moment to start with the fun! To load the data files, of the gene quantification, with the associated covariates the configuration file is loaded:

```{r eval = FALSE}
sampleTable <- read.table(configFile, header=TRUE, 
                          colClasses= c('factor','character','factor','factor', 
                                        'factor','factor'))
```

The counts have to be converted into a DESeq object. It takes the second column of the config file, which indicates where the counts of each sample are located. It is also necessary to specify the model, in which age, gender and pedigree are taken into consideration:

```{r eval = FALSE}
data <- DESeqDataSetFromHTSeqCount(sampleTable, directory=".", 
                                   design = ~ age + gender + PED + condition)
```

We are going to filter those genes that have a very low total number of counts, as can be considered more noise than useful information:

```{r eval = FALSE}
keep <- rowSums(counts(data)) >= 10
data <- data[keep,]
#With this filter, the object goes from 61806 elements to 28525 elements
```

Now it is time to run the DESEQ() function, which does the actual DGE analysis[@anders2010]. This function wraps three functions in one for easy usage, but I decided to run the three functions one by one to adjust the number of iterations.

```{r eval = FALSE}
dds <- estimateSizeFactors(data)
dds <- estimateDispersions(dds)
dds <- nbinomWaldTest(dds, maxit = 10000)
```

The function estimateSizeFactors() normalize each sample to the total number of reads on its library, using the median of ratios method. The estimateDispersions() function accounts for the within-groups variability, thus, the variability between samples with the same condition: this is specially important in this case because of the small sample size. The last function, nbinomWaldTest(), tests for significance of coefficients assuming a negative binomial distribution.

The variability of the data in DESeq is calculated by the formula \$ var = 𝜇 + 𝛼\*𝜇\^2 \$ where 𝜇 is the mean and 𝛼 the dispersion. For genes with high count values, \$ 𝛼 = var/𝜇 \$, therefore the dispersion estimate can reflect the variance in gene expression for a given mean. DESeq2 assumes that genes with similar average expression (calculated from all the samples) have similar dispersion. Each gene gets an estimation of its dispersion estimate using maximum likelihood (ML). Then a curve for expected dispersion value for genes with a given mean is fitted. Finally each gene dispersion is shrinkaged toward the fitted predicted curve: the recalculated dispersion value will be used in the later nbinomWaldTest() step, reducing drastically the number of false positives.

The dispersion plot can be produced:

```{r eval = FALSE}
tiff(filename = dispersionF, units="in", width=5, height=5, res=300)
title <- "Per-gene dispersion estimates"
plotDispEsts(dds, main=title)
invisible(dev.off())
```

![Figure X: Per-gene dispersion estimates](results_DGE/dispersion.tiff)

Though very crowded, it can be seen that most genes, specially with dispersions below the fitted expected curve, have been recalculated: the ones that have remained the same are the black dots surrounded by a blue circle. Also, the data fits the DESeq2 model because it scatters around the curve, and such fitted curve always present a negative slope (as it should according to the variability formula of DESeq2). I am going to save the results of both total counts and normalized counts for later use in other analysis.

```{r eval = FALSE}
dds_raw <- counts(dds, normalized=FALSE)
dds_normalized <- counts(dds, normalized=TRUE)
write.table(dds_raw, file=rawCountsF, quote=FALSE, 
             sep = "\t", col.names=NA)
write.table(dds_normalized, file=normCountsF, quote=FALSE, 
             sep = "\t", col.names=NA)
```

We must remove the effect of the covariates with the limma package and the function removeBatchEffect(): we don't want to see the effect of gender, age or family in the data, just the differences in expression due to condition, plus this is crucial to account for the different family structures that are present in each pedigree. The *covs* parameter must be set in **TRUE** to take away the covariates effect.

```{r eval = FALSE}
if (covs) {
  vst <- varianceStabilizingTransformation(dds, blind = FALSE)
  mat <- assay(vst)
  mm <- model.matrix(~condition, colData(vst))
  mat <- limma::removeBatchEffect(mat,
                                batch=vst$PED, batch2=vst$gender,
                                batch3=vst$age, design=mm)
  assay(vst) <- mat
} else {
  vst <- varianceStabilizingTransformation(dds, blind = FALSE)
  mat <- assay(vst)
}
```

The varianceStabilizingTransformation() function (or the wrapper vst()) normalizes the data by getting a vst factor from the fitted dispersion-mean relation and multiplies the count data divided by the size factor (which means that takes into account the library size). The *blind* parameter must be **FALSE** to take into account the experimental design with covariates.

An interesting feature of this package is that it provides functions for visualization of the input data, which can be used for quality control. The Principal Component Analysis would show if there are clusters or patterns in the data.

```{r eval = FALSE}
tiff(filename = PCAF, units="in", width=5, 
     height=5, res=300)
pca <- plotPCA(vst)
title <- "Principal Components Plot"
pca + ggtitle(title) + geom_text_repel(aes(label=colnames(vst)),size=1)
invisible(dev.off())
```

![Figure X: PCA](results_DGE/PCA.tiff)

No clusters separating unaffected and affected individuals are found, and this is expected: both groups share much of their genetic background, and bipolar disorder is a highly-complex polygenic disease.

Having go through all this, we extract the results of the DGE analysis with the results() function. To do so, first we have to get the factor levels:

```{r eval = FALSE}
#Get factor levels
levels <- unique(sampleTable$condition)
l1 <- toString(levels[2]) #reference level has to be Unaffected
l2 <- toString(levels[1])
suffix <- paste(l1, l2, sep="_vs_")
```

```{r eval = FALSE}
res <- results(dds, contrast=c("condition", l2, l1))
res$FoldChange <- 2^res$log2FoldChange  #have actual fold change
res <- res[colnames(res)[c(1,7,2:6)]] # order columns

#It is interesnting to add some extra info to the results:
symbol <- mapIds(get('org.Hs.eg.db'), keys=row.names(res), column="SYMBOL", 
                     keytype="ENSEMBL", multiVals="first") #to obtain gene symbols

description <- mapIds(get('org.Hs.eg.db'), keys=row.names(res),
                    column="GENENAME", keytype="ENSEMBL", 
                    multiVals="first") #to obtain description

res <- cbind(symbol, res)
res$description <- description
```

From the results object we can get the MA plot:

```{r eval = FALSE}
tiff(filename = MAplotF, units="in", width=5, height=5, res=300)
title <- paste("MA-plot", suffix, sep=" ")
plotMA(res, alpha= 0.05, main=title)
invisible(dev.off())
```

![Figure X: MA plot](results_DGE/maplot.tiff)

The MA plot shows the change in expression between condition groups against the mean expression across all the samples. On red there are those genes with an adjusted p value below 0.01. From this image we can also appreciate that the data follows the expected distribution as the points make a funnel shape.

I save the results object to get the list of significant differentially expressed genes:

```{r eval = F}
write.table (res, file=genesTSV, quote=FALSE, sep="\t", col.names=NA)
sig_pval <- subset(res, res$pvalue < cutoff)
write.table (sig_pval, file=sigTSV, quote=FALSE, sep="\t", col.names=NA)
```

Now we can clean and visualize the results with the arguably most popular graphs for the DGE analysis: the volcano plot and the heatmap. I want as well to create a PCA with only the significant genes, to check that the two gropus can be separated with this info. First we get an object of the significant genes:

```{r eval = FALSE}
#Get most significant genes according to cut off
significant <- subset(res, res$padj < cutoff)
significant <- significant[order(significant$padj),]
#Discard those genes with unbelievable Fold Change (outliers)
significant <- significant[(significant$log2FoldChange >= -FCthres) & 
                             (significant$log2FoldChange <= FCthres),]
```

I will account for the covariates again:

```{r eval = F}
interest_genes <- rownames(significant) #get the gene names
dds_sig <- dds[interest_genes,]
vst_sig <- varianceStabilizingTransformation(dds_sig, blind = FALSE)
mat_sig <- assay(vst_sig)
mm_sig <- model.matrix(~condition, colData(vst_sig))
mat_sig <- limma::removeBatchEffect(mat_sig,
                                batch=vst_sig$PED, batch2=vst_sig$gender,
                                batch3=vst_sig$age, design=mm_sig)
assay(vst_sig) <- mat_sig
```

And plot the PCA and save the results:

```{r eval = FALSE}
tiff(filename = sigPCAF, units="in", width=5, 
     height=5, res=300)
pca_sig <- plotPCA(vst_sig)
title <- "PCA - only significant genes"
pca_sig + ggtitle(title) + geom_text_repel(aes(label=colnames(vst_sig)), size=1.5)
invisible(dev.off())

write.table (significant, file=alphasigTSV, quote=FALSE, sep="\t", col.names=NA)
```

![Figure X: PCA of data only taking into account the significant genes with realistic fold change value](results_DGE/PCA_sig.tiff)

For the volcano plot we don't want to consider genes that don't have gene symbol.

```{r eval = FALSE}
discardNA <- !is.na(res$padj)
res2 <- res[discardNA,]
remove_outliers<- (res2$log2FoldChange >= -FCthres) & (res2$log2FoldChange <= FCthres) 
res2 <- res2[remove_outliers,]
```

To plot the volcano plot:

```{r eval = FALSE}
jpeg(filename = volcanoF, units="in", width=8, height=10, res=300)
EnhancedVolcano(res2, lab = res2$symbol, x = 'log2FoldChange', y = 'pvalue',
                pCutoff = 0.0002, FCcutoff= 0.3, 
                #pCutOff is p value for last significant acc to adjp value
                ylim = c(0, 11), xlim = c(-FCthres, FCthres), labSize = 3,
                legendLabSize = 9, legendIconSize = 5, drawConnectors = TRUE,
                widthConnectors = 0.5, max.overlaps = 50, title = '', arrowheads = FALSE,
                subtitle= '', gridlines.major = FALSE, gridlines.minor = FALSE)
invisible(dev.off())
```

![Figure X: Volcano plot](results_DGE/volcanoPlot.jpeg)

For the heatmap we create a new object that only and just has the genes of interest:

```{r eval = FALSE}
significant001 <- significant[significant$padj < 0.01,]
#Extract from the normalized counts table the data from the significant genes
subcounts <- subset(dds_normalized, rownames(dds_normalized) %in% 
                      rownames(significant001))
lsubcounts <- log2(subcounts+1) #added pseudocount 1
```

Set the variables for the plot:

```{r eval = FALSE}
sig_symbol <- as.character(significant001$symbol)
conditions <- c(l1, l2)
conds <- subset(sampleTable, sampleTable$condition %in% conditions)
samples <- conds$sample
```

To plot the heatmap:

```{r eval = FALSE}
df <- data.frame(condition=conds$condition)
rownames(df) <- samples
my_colour <- list(df=c(l1="skyblue", l2="orange"))
title <- "Heatmap of genes with adjusted p-value < 0.01"

jpeg(filename = heatmapF, units="in", width=8, height=5, res=300)
pheatmap(lsubcounts, scale= 'row', cluster_rows = TRUE,
         cluster_cols = TRUE, legend= TRUE, drop_levels = TRUE, 
         labels_row = make_italics(sig_symbol), 
         main = title,
         annotation_col = df, annotation_colors = my_colour,
         treeheight_row = 30, treeheight_col = 20)
invisible(dev.off())
```

![Figure X: Heat map of most significant genes](results_DGE/heatmap.jpeg) Though these genes show distinct patterns of expression in the different conditions, there are cases in which there may be, for instance, underexpression in affected and unaffected individuals: this is because their genetic background is shared and may be similar though one of them does develop the disease but not the other.

## Gene Set Enrichment Analysis

The Gene Set Enrichment Analysis (GSEA) doesn't looks if predefined sets of genes show a different pattern of expression[@subramanian2005]. The genes can be divided in sets according to their chromosomal location, cellular location of product, or as in this case, their function. I decided to use the Gene Ontology sets, focus on Molecular Process, which would give a rather simplified result [@liberzon2011]. This script is based in the one of the Genomics unit at CBMSO, from Eva Sacristán and Sandra González.

The first step is to call the libraries[@clusterProfiler; @msigdbr; @UpSetR; @enrichplot]:

```{r}
suppressPackageStartupMessages({
  library(rstudioapi)
  library(clusterProfiler, quietly = TRUE)
  library(msigdbr, quietly = T)
  library(UpSetR, quietly = TRUE)
  library(enrichplot, quietly = TRUE)
  library(ggplot2)
})
```

We declare the input and output files:

```{r eval = FALSE}
#Input
input <- 'results_DGE/all_genes.tsv'
#Outputs
resD <- 'results_GSEA/GO_BP'
resTSV <- paste0(resD,'GSEA_results.txt')
dotplotF <- paste0(resD, "dotplot.jpeg")
geneconceptF <- paste0(resD,"gene_concept_net.jpeg")
ridgeF <- paste0(resD,"GSEA_ridge.jpeg")
upsetF <- paste0(resD,"upset_plot.jpeg")
gseaplotsF <- paste0(resD,'all_gseaplots.jpeg')

```

Now let's set up the parameters

```{r eval = TRUE}
#Which database from msigdbr?
category <- 'C5'
subcategory <- 'GO:BP'
#Plot the x top categories
topCat <- 5
```

The 'hallmark' category in the mSigDB doesn't have any subcategories. We load the data:

```{r eval = FALSE}
data <- read.delim(input, sep= "\t", header=T, row.names = 1)
dat <- data$log2FoldChange
names(dat) <- as.character(rownames(data))
dat <- sort(dat, decreasing=TRUE)
```

In the data object *dat*, the row names are the genes, in their Ensembl ID, and only has other column, the log2fold change, which serves as measure of difference of expression. To further proceed, we request to get the data base sets in a local object:

```{r}
db_sets <- msigdbr(species = 'Homo sapiens', category = category, 
                   subcategory = subcategory)%>% 
  dplyr::select(gs_name, ensembl_gene)
head(db_sets)
```

Then the GSEA as it is is performed and saved.

```{r eval = FALSE}
set.seed(1)
egs <- GSEA(geneList = dat, pvalueCutoff = 0.05, eps = 0, pAdjustMethod = "BH", 
            seed = T, TERM2GENE = db_sets)
egs_df <- data.frame(egs@result)
egs_df <- egs_df[, -c(1,2)]
write.table(egs_df, file = resTSV, sep= "\t", quote = F, row.names = T)
```

Now that we have the results we can recalculate the *topCat* parameter: it is used to plot the top categories from the results, but in some cases there are less categories than expected. For a smooth run, it is better to evaluate this.

```{r eval = FALSE}
if (dim(egs_df)[1] < topCat){
  topCat <- dim(egs_df)[1]}

```

We can proceed to plot the results:

```{r eval=FALSE}
##Dotplot
jpeg(file = dotplotF, units = 'in', width = 15, height = 10, 
     res = 300)
par(mar = c(2, 2, 2, 5)) 
title <- 'Dot plot with GSEA categories'
dotplot(egs, x = "GeneRatio", color = "p.adjust", showCategory = 20, 
            font.size = 15, title = title)
invisible(dev.off())
```

![Figure X: dot plot with GSEA categories](results_GSEA/GO_BP/dotplot.jpeg) This dot plot shows ...

```{r eval = FALSE}
##Gene-concept network
jpeg(file = geneconceptF, units = 'in', 
     width = 15, height = 10, res = 300)
par(mar = c(2, 2, 2, 5)) 
cnetplot(egs, categorySize="p.adjust", font.size = 15, colorEdge = T)
invisible(dev.off())
```

![Figure X: Gene concept network graph](results_GSEA/GO_BP/gene_concept_net.jpeg) This plot shows....

```{r eval = FALSE}
##Ridge line plot
jpeg(file = ridgeF, units = 'in', width = 15, height = 10, res = 300)
par(mar = c(2, 2, 2, 5)) 
ridgeplot(egs, fill="p.adjust", orderBy= 'NES', core_enrichment = T)
invisible(dev.off())
```

![Figure X: Ridge plot of GSEA categories](results_GSEA/GO_BP/GSEA_ridge.jpeg) This plots shows ....

For the next visualization figures, it is necessary to design a list with each category that stores their belonging genes.

```{r eval = FALSE}
genes_top <- as.data.frame(as.factor(head(egs@result$core_enrichment, topCat)))
list_top <- list()
for (i in 1:topCat) {
    list_top[[i]] <- unlist(strsplit(as.character(genes_top[i,1]),split="/"))   
}
#Store all unique gene IDs
uniq <- as.character(unique(names(dat)))
#Get top functions
func_top <- egs$Description[1:topCat]
#Make sparse matrix with 1 for every gene in each category
mat <- matrix(0L, nrow = length(uniq), ncol = length(func_top)) 
for (gene in 1:length(uniq)) {
  for (func in 1:length(func_top)) {
    gen <- uniq[gene]
    if (gen %in% list_top[[func]]) {
      mat[gene,func] =  1
    }}} 
#Make a data frame
mat_df <- as.data.frame(mat)
colnames(mat_df) <- func_top
row.names(mat_df) <- uniq
```

With this data frame prepared, we can do the upset plot and the GSEA plots:

```{r eval = FALSE}
jpeg(file = upsetF, units = 'in', width = 15, height = 10, res = 300)
upset(mat_df, nsets=10, order.by="freq", sets.bar.color="skyblue")
invisible(dev.off())
```

![Figure X: Upset plot](results_GSEA/GO_BP/upset_plot.jpeg) This plot shows...

```{r eval = FALSE}
for (j in 1:numPlots){
  pl <- gseaplot2(egs, geneSetID=j, title = egs$Description[j], base_size=40, color="red")
  desc <- gsub(" ", "_", egs$Description[j], fixed = TRUE) 
  filename <- paste0(resD, desc, ".jpeg")
  ggsave(pl, file=filename, device = "jpeg", units= "in", height = 15, width = 20)
}
```

![Figure X: category \_ GSEA plot](results_GSEA/GO_BP/GOBP_ADAPTIVE_IMMUNE_RESPONSE_BASED_ON_SOMATIC_RECOMBINATION_OF_IMMUNE_RECEPTORS_BUILT_FROM_IMMUNOGLOBULIN_SUPERFAMILY_DOMAINS.jpeg) ![Figure X: category \_ GSEA plot](results_GSEA/GO_BP/GOBP_IMMUNOGLOBULIN_PRODUCTION.jpeg)

![Figure X: category \_ GSEA plot](results_GSEA/GO_BP/GOBP_NEGATIVE_REGULATION_OF_DNA_BINDING.jpeg)

![Figure X: category \_ GSEA plot](results_GSEA/GO_BP/GOBP_PRODUCTION_OF_MOLECULAR_MEDIATOR_OF_IMMUNE_RESPONSE.jpeg)

These plots show.... We can fuse all this plots together by:

```{r eval = FALSE}
gseap <- gseaplot2(egs, geneSetID = 1:topCat, pvalue_table = F)
ggsave(gseap, file=gseaplotsF, device = "jpeg", units= "in", 
       height = 15, width = 20)
```

![Figure X: category \_ GSEA plot](results_GSEA/GO_BP/all_gseaplots.jpeg)

# Weighted Gene Coexpression Network Analysis

The Weighted Gene Coexpression Network Analysis (WGCNA) is... [@langfelder2008]I have divided the scripts in five parts for simplicity reasons. They are based on the WGCNA tutorials made by Peter Langfelder and Steve Horvarth [@langfelderhorvarth2008].

## Part 1: Data preparation

dd

## Part 2: Network construction

dd

## Part 3: module membership and gene significance

ss

## Part 4: comparison with DGE

dd

## Part 5: Visualization

ss

# References

::: {#refs}
:::
